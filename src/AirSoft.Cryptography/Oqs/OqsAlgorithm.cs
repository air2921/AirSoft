using AirSoft.Cryptography.Abstractions;
using AirSoft.Exceptions;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;

namespace AirSoft.Cryptography.Oqs
{
    /// <summary>
    /// Abstract base class implementing post-quantum cryptographic signature algorithms
    /// using the Open Quantum Safe (OQS) library.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class provides a managed wrapper around the native OQS library functions for:
    /// <list type="bullet">
    /// <item><description>Key pair generation</description></item>
    /// <item><description>Message signing</description></item>
    /// <item><description>Signature verification</description></item>
    /// </list>
    /// </para>
    /// 
    /// <para>
    /// The class implements the <see cref="IDisposable"/> pattern to properly manage native resources:
    /// <list type="bullet">
    /// <item><description>Automatically extracts and loads the native OQS DLL</description></item>
    /// <item><description>Manages lifetime of native signature objects</description></item>
    /// <item><description>Cleans up temporary files on process exit</description></item>
    /// </list>
    /// </para>
    /// 
    /// <para>
    /// Thread safety is implemented through:
    /// <list type="bullet">
    /// <item><description><see cref="_libLock"/> for library initialization</description></item>
    /// <item><description><see cref="_pointerLock"/> for cryptographic operations</description></item>
    /// <item><description>Volatile fields for cross-thread visibility</description></item>
    /// </list>
    /// </para>
    /// 
    /// <para>
    /// Derived classes must:
    /// <list type="bullet">
    /// <item><description>Specify a valid <see cref="IOqsAlgorithmFormat"/></description></item>
    /// <item><description>Implement algorithm-specific validation if needed</description></item>
    /// <item><description>Optionally extend the disposal pattern</description></item>
    /// </list>
    /// </para>
    /// 
    /// <seealso cref="IDisposable"/>
    /// <seealso cref="IOqsAlgorithmFormat"/>
    /// </remarks>
    public class OqsAlgorithm : IDisposable
    {
        /// <summary>
        /// The algorithm format specification containing parameters and metadata for the quantum-safe cryptographic algorithm.
        /// </summary>
        /// <remarks>
        /// This field holds an implementation of <see cref="IOqsAlgorithmFormat"/> that defines:
        /// - The algorithm name (e.g., "Dilithium2")
        /// - Key lengths (public and private)
        /// - Signature length
        /// - Resource name for the native library
        /// It is initialized during construction and used throughout the class for algorithm-specific operations.
        /// The format must pass validation via <see cref="IsValidFormat"/> before being used.
        /// </remarks>
        private readonly IOqsAlgorithmFormat _algorithmFormat;

        /// <summary>
        /// The path to the temporary location where the <c>oqs</c> library is stored.
        /// </summary>
        /// <remarks>
        /// This path is generated by joining the system's temporary directory with the filename <c>oqs</c>.
        /// It is used to load the native <c>oqs</c> library during the initialization of the class.
        /// </remarks>
        private readonly string _oqsPath;

        /// <summary>
        /// A flag indicating whether the instance has been disposed.
        /// </summary>
        /// <remarks>
        /// This field is used to track whether the object has been disposed, ensuring that no operations
        /// are performed on the instance after it has been disposed.
        /// </remarks>
        private volatile bool _disposed;

        #region Pointers

        /// <summary>
        /// A pointer to the loaded <c>oqs</c> library.
        /// </summary>
        /// <remarks>
        /// This handle is used to interact with the native library and resolve function pointers for cryptographic operations.
        /// </remarks>
        private volatile IntPtr _oqsLibraryHandle;

        /// <summary>
        /// A pointer to the signature object created for the Dilithium algorithm.
        /// </summary>
        /// <remarks>
        /// This object is initialized during the class instantiation and is used to perform signing and verification operations.
        /// </remarks>
        private volatile IntPtr _sig;

        #endregion

        #region Delegates

        /// <summary>
        /// Delegate for the <c>OQS_SIG_new</c> function in the native library, used to initialize a new signature object.
        /// </summary>
        /// <remarks>
        /// This function is used to create an instance of the signature scheme for a specific algorithm.
        /// </remarks>
        private delegate IntPtr OQS_SIG_newDelegate(string alg_name);

        /// <summary>
        /// Delegate for the <c>OQS_SIG_free</c> function in the native library, used to free the signature object.
        /// </summary>
        /// <remarks>
        /// This function is used to release resources associated with a signature scheme instance.
        /// </remarks>
        private delegate void OQS_SIG_freeDelegate(IntPtr sig);

        /// <summary>
        /// Delegate for the <c>OQS_SIG_keypair</c> function in the native library, used to generate key pairs.
        /// </summary>
        /// <remarks>
        /// This function is used to generate a public/private key pair for the signature scheme.
        /// </remarks>
        protected delegate int OQS_SIG_keypairDelegate(IntPtr sig, byte[] public_key, byte[] private_key);

        /// <summary>
        /// Delegate for the <c>OQS_SIG_sign</c> function in the native library, used to sign a message.
        /// </summary>
        /// <remarks>
        /// This function is used to create a signature for a message using the private key.
        /// </remarks>
        protected delegate int OQS_SIG_signDelegate(IntPtr sig, byte[] signature, out long signature_len, byte[] message, long message_len, byte[] private_key);

        /// <summary>
        /// Delegate for the <c>OQS_SIG_verify</c> function in the native library, used to verify a signature.
        /// </summary>
        /// <remarks>
        /// This function is used to verify a signature against a message and public key.
        /// </remarks>
        protected delegate int OQS_SIG_verifyDelegate(IntPtr sig, byte[] message, long message_len, byte[] signature, long signature_len, byte[] public_key);

        /// <summary>
        /// The delegate for the <c>OQS_SIG_new</c> function, used for initializing the signature object.
        /// </summary>
        /// <remarks>
        /// This delegate is resolved at runtime and used to initialize a new signature instance for the Dilithium algorithm.
        /// </remarks>
        private OQS_SIG_newDelegate _oqsSigNew = null!;

        /// <summary>
        /// The delegate for the <c>OQS_SIG_free</c> function, used for freeing the signature object.
        /// </summary>
        /// <remarks>
        /// This delegate is resolved at runtime and used to release the resources of a signature instance.
        /// </remarks>
        private OQS_SIG_freeDelegate _oqsSigFree = null!;

        /// <summary>
        /// The delegate for the <c>OQS_SIG_keypair</c> function, used for generating key pairs.
        /// </summary>
        /// <remarks>
        /// This delegate is resolved at runtime and used to generate public and private key pairs for the Dilithium algorithm.
        /// </remarks>
        private OQS_SIG_keypairDelegate _oqsSigKeypair = null!;

        /// <summary>
        /// The delegate for the <c>OQS_SIG_sign</c> function, used for signing messages.
        /// </summary>
        /// <remarks>
        /// This delegate is resolved at runtime and used to create a signature for a message using the private key.
        /// </remarks>
        private OQS_SIG_signDelegate _oqsSigSign = null!;

        /// <summary>
        /// The delegate for the <c>OQS_SIG_verify</c> function, used for verifying signatures.
        /// </summary>
        /// <remarks>
        /// This delegate is resolved at runtime and used to verify the authenticity of a signature against a message.
        /// </remarks>
        private OQS_SIG_verifyDelegate _oqsSigVerify = null!;

        #endregion

        #region Lock Objects

        /// <summary>
        /// Lock object to synchronize access to the library handle during initialization and function resolution.
        /// </summary>
        /// <remarks>
        /// This object ensures that library loading and delegate resolution are thread-safe.
        /// </remarks>
        private readonly object _libLock = new object();

        /// <summary>
        /// Lock object to synchronize access to the signature object during cryptographic operations.
        /// </summary>
        /// <remarks>
        /// This object ensures thread safety when performing signature operations such as signing and verification.
        /// </remarks>
        private readonly object _pointerLock = new object();

        #endregion

        #region Properties

        /// <summary>
        /// Gets the algorithm format descriptor associated with this instance.
        /// </summary>
        /// <remarks>
        /// Provides access to the metadata and parameters (e.g., key lengths, algorithm name)
        /// defined by the <see cref="IOqsAlgorithmFormat"/> implementation passed during construction.
        /// </remarks>
        /// <exception cref="ObjectDisposedException">Thrown if the <b>oqs</b> has been disposed</exception>
        protected IOqsAlgorithmFormat AlgorithmFormat
        {
            get
            {
                CheckDisposed();
                return _algorithmFormat;
            }
        }

        /// <summary>
        /// Gets the pointer to the native signature object.
        /// </summary>
        /// <remarks>
        /// This pointer refers to the native structure used internally by the OQS library
        /// to perform signing and verification operations.
        /// </remarks>
        /// <exception cref="ObjectDisposedException">Thrown if the <b>oqs</b> has been disposed</exception>
        protected IntPtr Signature
        {
            get
            {
                CheckDisposed();
                return _sig;
            }
        }

        /// <summary>
        /// Gets the delegate used to generate key pairs via the native OQS library.
        /// </summary>
        /// <remarks>
        /// Resolves to the <c>OQS_SIG_keypair</c> function used to generate algorithm-specific
        /// public and private key pairs.
        /// </remarks>
        /// <exception cref="ObjectDisposedException">Thrown if the <b>oqs</b> has been disposed</exception>
        protected OQS_SIG_keypairDelegate CreateKeyPair
        {
            get
            {
                CheckDisposed();
                return _oqsSigKeypair;
            }
        }

        /// <summary>
        /// Gets the delegate used to sign messages via the native OQS library.
        /// </summary>
        /// <remarks>
        /// Resolves to the <c>OQS_SIG_sign</c> function used to create digital signatures
        /// based on the selected algorithm and private key.
        /// </remarks>
        /// <exception cref="ObjectDisposedException">Thrown if the <b>oqs</b> has been disposed</exception>
        protected OQS_SIG_signDelegate Sign
        {
            get
            {
                CheckDisposed();
                return _oqsSigSign;
            }
        }

        /// <summary>
        /// Gets the delegate used to verify message signatures via the native OQS library.
        /// </summary>
        /// <remarks>
        /// Resolves to the <c>OQS_SIG_verify</c> function that checks the validity of a
        /// signature against a message and public key.
        /// </remarks>
        /// <exception cref="ObjectDisposedException">Thrown if the <b>oqs</b> has been disposed</exception>
        protected OQS_SIG_verifyDelegate Verify
        {
            get
            {
                CheckDisposed();
                return _oqsSigVerify;
            }
        }

        /// <summary>
        /// Gets the synchronization object used for locking access to native pointers.
        /// </summary>
        /// <remarks>
        /// Used internally to ensure thread-safe cryptographic operations by synchronizing
        /// access to <see cref="_sig"/> and related unmanaged resources.
        /// </remarks>
        /// <exception cref="ObjectDisposedException">Thrown if the <b>oqs</b> has been disposed</exception>
        protected object PointerSync
        {
            get
            {
                CheckDisposed();
                return _pointerLock;
            }
        }

        #endregion

        #region Constructor and Finalizer

        /// <summary>
        /// Initializes a new instance of the <see cref="OqsAlgorithm"/> class.
        /// Automatically creates and validates the algorithm format specification.
        /// </summary>
        /// <param name="algorithmFormat">The algorithm format specification to use</param>
        /// <exception cref="CryptographyException">
        /// Thrown when:
        /// <list type="bullet">
        ///   <item><description>The algorithm format fails validation (via <see cref="IsValidFormat"/>)</description></item>
        ///   <item><description>Failed to load or initialize the native OQS library</description></item>
        ///   <item><description>Failed to create the signature scheme instance</description></item>
        /// </list>
        /// </exception>
        /// <remarks>
        /// <para>
        /// The constructor performs the following operations:
        /// <list type="number">
        ///   <item><description>Initializes a logger instance with both Serilog and Console output</description></item>
        ///   <item><description>Validates the algorithm format using <see cref="IsValidFormat"/></description></item>
        ///   <item><description>Stores the validated format in <see cref="_algorithmFormat"/></description></item>
        ///   <item><description>Initializes native resources by calling <see cref="PointerResolve"/></description></item>
        ///   <item><description>Registers a process exit handler to clean up the temporary DLL file</description></item>
        /// </list>
        /// </para>
        /// 
        /// <para>
        /// Note: The temporary OQS library file file (<see cref="_oqsPath"/>) is automatically deleted when the process exits.
        /// Any errors during deletion are logged but otherwise ignored.
        /// </para>
        /// 
        /// <para>
        /// Thread safety: Constructor execution is not thread-safe. The caller must ensure proper synchronization
        /// when creating multiple instances concurrently.
        /// </para>
        /// </remarks>
        protected OqsAlgorithm(IOqsAlgorithmFormat algorithmFormat)
        {
            _algorithmFormat = algorithmFormat;
            _oqsPath = Path.Join(Path.GetTempPath(), algorithmFormat.FileName);

            if (!IsValidFormat())
                throw new CryptographyException("Invalid algorithm format");

            PointerResolve();

            OnAppDown();
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="OqsAlgorithm"/> class.
        /// </summary>
        /// <remarks>
        /// This destructor ensures that unmanaged resources are properly released
        /// if the object was not explicitly disposed. It calls <see cref="Dispose(bool)"/>
        /// with <c>false</c> to perform cleanup of unmanaged resources only.
        /// 
        /// Note: The destructor is only called if <see cref="Dispose()"/> was not called.
        /// </remarks>
        ~OqsAlgorithm()
        {
            Dispose(false);
        }

        #endregion

        #region Event Subscribers

        /// <summary>
        /// Subscribes to application shutdown events to perform cleanup operations
        /// </summary>
        /// <remarks>
        /// This method registers a handler for the <see cref="AppDomain.ProcessExit"/> event
        /// to delete temporary DLL files when the application is shutting down.
        /// </remarks>
        protected virtual void OnAppDown()
        {
            AppDomain.CurrentDomain.ProcessExit += (sender, args) =>
            {
                try
                {
                    File.Delete(_oqsPath);
                }
                catch
                {
                }
            };
        }

        #endregion

        #region Resolvers

        /// <summary>
        /// Initializes and resolves all required native function pointers for the OQS algorithm.
        /// </summary>
        /// <exception cref="CryptographyException">
        /// Thrown when:
        /// <list type="bullet">
        /// <item><description>The embedded DLL resource cannot be found or extracted</description></item>
        /// <item><description>The native library fails to load</description></item>
        /// <item><description>The signature scheme initialization fails</description></item>
        /// <item><description>Any required native function cannot be resolved</description></item>
        /// </list>
        /// </exception>
        /// <remarks>
        /// <para>This method performs the following operations in a thread-safe manner:</para>
        /// <list type="number">
        /// <item><description>Extracts the embedded OQS DLL to a temporary file if not already present</description></item>
        /// <item><description>Loads the native library and resolves oqs handler via <see cref="ResolveHandler"/></description></item>
        /// <item><description>Resolves all required function delegates via <see cref="Resolve"/></description></item>
        /// <item><description>Initializes the signature scheme instance via <see cref="ResolveSignature"/></description></item>
        /// </list>
        /// <para>The operation is protected by <see cref="_libLock"/> to ensure thread safety during:</para>
        /// <list type="bullet">
        /// <item><description>DLL extraction</description></item>
        /// <item><description>Library loading</description></item>
        /// <item><description>Function resolution</description></item>
        /// <item><description>Signature scheme initialization</description></item>
        /// </list>
        /// </remarks>
        private void PointerResolve()
        {
            lock (_libLock)
            {
                try
                {
                    ResolveHandler();
                    Resolve();
                    ResolveSignature();
                }
                catch (Exception ex)
                {
                    if (ex is CryptographyException)
                        throw;

                    throw new CryptographyException("An error occurred while trying to resolve native functions from the oqs library", ex);
                }
            }
        }

        /// <summary>
        /// Resolves all required native function delegates from the OQS library.
        /// </summary>
        /// <remarks>
        /// This method initializes delegates for the following OQS functions:
        /// <list type="bullet">
        /// <item><description>OQS_SIG_new - Creates new instances of the signature scheme</description></item>
        /// <item><description>OQS_SIG_free - Cleans up signature scheme instances</description></item>
        /// <item><description>OQS_SIG_keypair - Generates public/private key pairs</description></item>
        /// <item><description>OQS_SIG_sign - Creates message signatures</description></item>
        /// <item><description>OQS_SIG_verify - Verifies message signatures</description></item>
        /// </list>
        /// </remarks>
        private void Resolve()
        {
            _oqsSigNew = ResolveDelegate<OQS_SIG_newDelegate>("OQS_SIG_new");
            _oqsSigFree = ResolveDelegate<OQS_SIG_freeDelegate>("OQS_SIG_free");
            _oqsSigKeypair = ResolveDelegate<OQS_SIG_keypairDelegate>("OQS_SIG_keypair");
            _oqsSigSign = ResolveDelegate<OQS_SIG_signDelegate>("OQS_SIG_sign");
            _oqsSigVerify = ResolveDelegate<OQS_SIG_verifyDelegate>("OQS_SIG_verify");
        }

        /// <summary>
        /// Handles the extraction and loading of the native OQS library.
        /// </summary>
        /// <exception cref="CryptographyException">
        /// Thrown when:
        /// <list type="bullet">
        /// <item><description>The embedded resource cannot be found</description></item>
        /// <item><description>The DLL file cannot be created</description></item>
        /// <item><description>The native library fails to load</description></item>
        /// </list>
        /// </exception>
        /// <remarks>
        /// <para>This method performs the following operations:</para>
        /// <list type="number">
        /// <item><description>Checks if the OQS library file already exists at <see cref="_oqsPath"/></description></item>
        /// <item><description>If not found, extracts the embedded resource <see cref="IOqsAlgorithmFormat.ResourceName"/> to the target path</description></item>
        /// <item><description>Loads the native library using <see cref="NativeLibrary.Load(string)"/></description></item>
        /// </list>
        /// <para>The DLL extraction is performed with exclusive file access to prevent race conditions.</para>
        /// </remarks>
        private void ResolveHandler()
        {
            if (!File.Exists(_oqsPath))
            {
                using var assemblyStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(_algorithmFormat.ResourceName)
                    ?? throw new CryptographyException($"Embedded resource '{_algorithmFormat.ResourceName}' not found");

#pragma warning disable IDE0063
                using (var fileStream = new FileStream(_oqsPath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None, 4096))
                    assemblyStream.CopyTo(fileStream);
#pragma warning restore IDE0063
            }

            _oqsLibraryHandle = NativeLibrary.Load(_oqsPath);
            if (_oqsLibraryHandle == IntPtr.Zero)
                throw new CryptographyException($"Failed to load native library at '{_oqsPath}'");
        }

        /// <summary>
        /// Initializes the signature scheme instance using the resolved OQS_SIG_new delegate.
        /// </summary>
        /// <exception cref="CryptographyException">
        /// Thrown when the signature scheme cannot be initialized (returns null pointer)
        /// </exception>
        /// <remarks>
        /// <para>This method:</para>
        /// <list type="number">
        /// <item><description>Uses the resolved <see cref="_oqsSigNew"/> delegate</description></item>
        /// <item><description>Passes the algorithm name from <see cref="IOqsAlgorithmFormat.Algorithm"/></description></item>
        /// <item><description>Verifies successful initialization by checking for non-zero pointer</description></item>
        /// </list>
        /// <para>The created signature scheme instance must be freed using OQS_SIG_free during disposal.</para>
        /// </remarks>
        private void ResolveSignature()
        {
            _sig = _oqsSigNew(_algorithmFormat.Algorithm);
            if (_sig == IntPtr.Zero)
                throw new CryptographyException($"Signature scheme '{_algorithmFormat.Algorithm}' initialization failed");
        }

        /// <summary>
        /// Resolves a single native function delegate from the OQS library.
        /// </summary>
        /// <typeparam name="TDelegate">The delegate type to resolve</typeparam>
        /// <param name="functionName">Name of the native function to resolve</param>
        /// <returns>A delegate that can be used to call the native function</returns>
        /// <exception cref="DllNotFoundException">
        /// Thrown when the specified function cannot be found in the native library
        /// </exception>
        /// <remarks>
        /// This helper method:
        /// <list type="number">
        /// <item><description>Logs the resolution attempt</description></item>
        /// <item><description>Gets the function pointer from the native library</description></item>
        /// <item><description>Marshals the pointer to the specified delegate type</description></item>
        /// </list>
        /// Corresponds to the native function lookup and delegate creation process.
        /// </remarks>
        private TDelegate ResolveDelegate<TDelegate>(string functionName) where TDelegate : Delegate
        {
            var functionPtr = NativeLibrary.GetExport(_oqsLibraryHandle, functionName);
            return Marshal.GetDelegateForFunctionPointer<TDelegate>(functionPtr);
        }

        #endregion

        #region Validators

        /// <summary>
        /// Validates the algorithm format parameters.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the format meets all validation requirements; otherwise, <c>false</c>.
        /// </returns>
        /// <remarks>
        /// This method performs comprehensive validation by checking:
        /// 1. Signature length validity via <see cref="IsValidSignatureLength"/>
        /// 2. Key length validity via <see cref="IsValidKeyLength"/>
        /// 
        /// The method is marked as virtual to allow derived classes to extend the validation logic.
        /// </remarks>
        protected virtual bool IsValidFormat()
        {
            if (!IsValidSignatureLength())
                return false;

            if (!IsValidKeyLength())
                return false;

            return true;
        }

        /// <summary>
        /// Validates the key lengths specified in the algorithm format.
        /// </summary>
        /// <returns>
        /// <c>true</c> if both public and private key lengths are non-zero; otherwise, <c>false</c>.
        /// </returns>
        /// <remarks>
        /// Ensures the algorithm format specifies valid lengths for:
        /// - Public key (<see cref="IOqsAlgorithmFormat.PublicKeyLength"/>)
        /// - Private key (<see cref="IOqsAlgorithmFormat.PrivateKeyLength"/>)
        /// </remarks>
        private bool IsValidKeyLength()
        {
            if (_algorithmFormat.PublicKeyLength == 0 || _algorithmFormat.PrivateKeyLength == 0)
                return false;

            return true;
        }

        /// <summary>
        /// Validates the signature length specified in the algorithm format.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the signature length is non-zero; otherwise, <c>false</c>.
        /// </returns>
        /// <remarks>
        /// Checks that <see cref="IOqsAlgorithmFormat.SignatureLength"/> contains a valid positive value.
        /// </remarks>
        private bool IsValidSignatureLength()
        {
            if (_algorithmFormat.SignatureLength == 0)
                return false;

            return true;
        }

        #endregion

        #region Disposable

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        /// <param name="disposing">
        /// <c>true</c> to release both managed and unmanaged resources;
        /// <c>false</c> to release only unmanaged resources.
        /// </param>
        /// <remarks>
        /// This method implements the standard dispose pattern and performs the following operations:
        /// 1. Checks the disposal state via <see cref="_disposed"/> flag to prevent duplicate disposal
        /// 2. Uses <see cref="_pointerLock"/> to ensure thread-safe cleanup
        /// 3. Releases the signature object via <see cref="_oqsSigFree"/> if <see cref="_sig"/> is initialized
        /// 4. Conditionally frees the native library handle (<see cref="_oqsLibraryHandle"/>) when <paramref name="disposing"/> is true
        /// 5. Sets the <see cref="_disposed"/> flag to prevent future operations on disposed instance
        ///
        /// Note: When called with <c>false</c> (from finalizer), only unmanaged resources are released.
        /// Derived classes should override this method to add their own cleanup logic while calling base.Dispose(disposing).
        /// </remarks>
        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            lock (_pointerLock)
            {
                if (_sig != IntPtr.Zero)
                {
                    _oqsSigFree(_sig);
                    _sig = IntPtr.Zero;
                }

                if (_oqsLibraryHandle != IntPtr.Zero)
                {
                    NativeLibrary.Free(_oqsLibraryHandle);
                    _oqsLibraryHandle = IntPtr.Zero;
                }
            }

            if (disposing)
            {
                // Call Dispose() on all objects implementing IDisposable, if any.
                // This object does not own any objects that implement IDisposable.
            }

            _disposed = true;
        }

        /// <summary>
        /// Releases all resources used by the current instance of <see cref="OqsAlgorithm"/>.
        /// </summary>
        /// <remarks>
        /// This method:
        /// 1. Calls <see cref="Dispose(bool)"/> with <c>true</c> to release all resources
        /// 2. Suppresses finalization via <see cref="GC.SuppressFinalize"/> to prevent redundant cleanup
        /// 3. Should be called explicitly when the instance is no longer needed
        ///
        /// After calling Dispose(), the object should not be used as it may leave the instance in an unusable state.
        /// </remarks>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Verifies that the instance has not been disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">
        /// Thrown when the instance has already been disposed.
        /// </exception>
        /// <remarks>
        /// <para>
        /// This method should be called at the start of any public method or property that requires
        /// access to the instance's resources.
        /// </para>
        /// <para>
        /// The check is performed by verifying the <see cref="_disposed"/> flag. If the flag is set to <c>true</c>,
        /// the method throws an <see cref="ObjectDisposedException"/> with the current instance's type name.
        /// </para>
        /// </remarks>
        protected virtual void CheckDisposed()
        {
            if (_disposed)
                throw new ObjectDisposedException(GetType().FullName);
        }

        #endregion
    }
}
